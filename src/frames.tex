\begin{frame}
  \titlepage
  \hypertarget{titlePage}{}
\end{frame}

\begin{frame}
  \frametitle{Write path}
  \sqlinline{CREATE TABLE arrs (pk char, a int[]);}

  \sqlinline{CREATE INDEX ON arrs USING gin (a);}
  \pause

  \sqlinline{INSERT INTO arrs VALUES ('i', '{1, 3, 5, 3}');}
  \pause

  \begin{itemize}
    \item insert to the main table
      \pause
      \begin{itemize}
        \item \sqlinline{'i'} $\mapsto$ \sqlinline{'{1, 3, 5, 3}'}
      \end{itemize}
      \pause
    \item insert to the secondary index
      \pause
      \begin{itemize}
        \item extract deduped scan entries: \sqlinline{1}, \sqlinline{3},
          \sqlinline{5}
          \pause
        \item write records \emph{entry} $\mapsto$ \emph{pk}:
          \pause
          \begin{itemize}
            \item \sqlinline{1} $\mapsto$ \sqlinline{'i'}
              \pause
            \item \sqlinline{3} $\mapsto$ \sqlinline{'i'}
              \pause
            \item \sqlinline{5} $\mapsto$ \sqlinline{'i'}
          \end{itemize}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{More inserts}
  For the sake of future examples, insert more rows:

  \sqlinline{-- previous: INSERT INTO arrs VALUES ('i', '{1, 3, 5, 3}');}

  \sqlinline{INSERT INTO arrs VALUES ('j', '{1, 3, 2}');}

  \sqlinline{INSERT INTO arrs VALUES ('k', '{5, 3}');}
  \pause

  What would the index look like after these inserts?
  \pause

  \begin{itemize}
    \item \sqlinline{1} $\mapsto$ \sqlinline{'i'}
    \item \sqlinline{1} $\mapsto$ \sqlinline{'j'}
    \item \sqlinline{2} $\mapsto$ \sqlinline{'j'}
    \item \sqlinline{3} $\mapsto$ \sqlinline{'i'}
    \item \sqlinline{3} $\mapsto$ \sqlinline{'j'}
    \item \sqlinline{3} $\mapsto$ \sqlinline{'k'}
    \item \sqlinline{5} $\mapsto$ \sqlinline{'i'}
    \item \sqlinline{5} $\mapsto$ \sqlinline{'k'}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Read path}
  Select rows whose array column intersects with \sqlinline{'{5}'}:

  \sqlinline{SELECT * FROM arrs WHERE a && '{5}';}
  \pause

  \emph{Note: this will be an index scan (not index only scan).}
  \pause

  \begin{itemize}
    \item extract scan entries: \sqlinline{5}
      \pause
    \item set up binds on index
      \begin{itemize}
        \item \textinline{a}$'$ $=$ \sqlinline{5}
      \end{itemize}
      \pause
    \item set up targets on both index and indexed table
      \begin{itemize}
        \item \cinline{YBIdxBaseTupleIdAttributeNumber} for index
          \pause
        \item \cinline{YBTupleIdAttributeNumber} for table
          \pause
        \item \textinline{pk} for table for \sqlinline{SELECT *}
          \pause
        \item \textinline{a} for table for \sqlinline{SELECT *}
      \end{itemize}
      \pause
    \item retrieve each row and recheck condition (unnecessary here)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Read path with AND}
  Select rows whose array column contains elements \sqlinline{1} \emph{and}
  \sqlinline{3}:

  \sqlinline{SELECT * FROM arrs WHERE a @> '{3, 1, 1, 3}';}
  \pause

  \begin{itemize}
    \item extract scan entries: \sqlinline{1}, \sqlinline{3}
      \pause
    \item \textbf{split to required and additional entries}:
      \pause
      \begin{itemize}
        \item ideally, the less frequent scan entry is chosen required:
          \sqlinline{1} should be required
          \pause
        \item currently, hueristics aren't present, so it's arbitrary:
          \sqlinline{1} is additional, \sqlinline{3} is required
      \end{itemize}
      \pause
    \item set up binds on index
      \begin{itemize}
        \item \textinline{a}$'$ $=$ \sqlinline{3}
      \end{itemize}
      \pause
    \item set up targets on both index and indexed table
      \begin{itemize}
        \item \cinline{YBIdxBaseTupleIdAttributeNumber} for index
        \item \cinline{YBTupleIdAttributeNumber} for table
        \item \textinline{pk} for table for \sqlinline{SELECT *}
        \item \textinline{a} for table for \sqlinline{SELECT *}
      \end{itemize}
      \pause
    \item retrieve each row and recheck condition
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Read path with OR}
  Select rows whose array column intersects with \sqlinline{'{1, 2}'}:

  \sqlinline{SELECT * FROM arrs WHERE a && '{2, 1, 2}';}
  \pause

  \begin{itemize}
    \item extract scan entries: \sqlinline{1}, \sqlinline{2}
      \pause
    \item split to required and additional entries: both are required
      \pause
    \item next, a couple options:
      \pause
      \begin{enumerate}
        \item don't allow more than one required scan entry: user can rewrite
          the query as \sqlinline{WHERE a && '{1}' or a && '{2}'}
          \pause
        \item do point index scans separately, deduplicate pkeys in postgres,
          then do table scans
        \item try IN bind: bind \textinline{a}$'$ IN \{\sqlinline{1},
          \sqlinline{2}\}, but make sure to deduplicate pkeys (e.g.\ the row
          with pkey \sqlinline{'j'})
          \pause
        \item create a new bind operator to achieve the above
          \pause
      \end{enumerate}
      \pause
    \item retrieve each row and recheck condition (unnecessary here)
  \end{itemize}
\end{frame}
